
"""This is a three-card tarot reading for the querent's question: "{userInput}".
The focus area is: {userContext}.

The spread is as follows:
- Past: {card1.name} ({card1.reversed ? "reversed" : "upright"}) – {card1.reversed ? card1.meaningRev : card1.meaningUp}
- Present: {card2.name} ({card2.reversed ? "reversed" : "upright"}) – {card2.reversed ? card2.meaningRev : card2.meaningUp}
- Future: {card3.name} ({card3.reversed ? "reversed" : "upright"}) – {card3.reversed ? card3.meaningRev : card3.meaningUp}

Provide a nuanced, cohesive reading that addresses the querent's inquiry and focus area."""


maybe sth like `/api/tarot/prompt_reading` as an endpoint? 

```
@RestController
public class TarotController {
    @PostMapping("/api/tarot/prompt_reading")
    public ResponseEntity<String> getReading(@RequestBody TarotReadingRequest request) {
        // construct prompt
        String prompt = buildPrompt(request);
        // call an LLM API
        String reading = callLLMAPI(prompt);
        return ResponseEntity.ok(reading);
    }

    private String buildPrompt(TarotReadingRequest request) {
        // Logic to build the prompt as shown above
    }
}
```


Bucket4j, Spring Cloud Gateway?

```
// In your controller
@PostMapping("/api/tarot/prompt_reading")
public ResponseEntity<?> getReading(@RequestBody TarotReadingRequest request, HttpServletRequest servletRequest) {
    String userId = servletRequest.getRemoteAddr(); // Or use a user auth token
    if (rateLimiter.tryConsume(userId)) {
        String reading = callLLMAPI(buildPrompt(request));
        return ResponseEntity.ok(reading);
    } else {
        return ResponseEntity.status(429).body("Free reads limit exceeded. Upgrade for more, or try our BYOK system.");
    }
}
```

use stripe, maybe? 
ideally go for cheapness
maybe $1/$5? 
see how many reads it buys once i figure out how long the celtic cross spread prompts will be, make a reasonable deal

payment redirect modal:

```
const [showUpgradeModal, setShowUpgradeModal] = useState(false);

const handleSaveReading = async () => {
  try {
    const response = await fetch("/api/tarot/prompt_reading", {
      method: "POST",
      body: JSON.stringify({ /* spread data */ }),
    });
    if (response.status === 429) {
      setShowUpgradeModal(true);
    } else {
      const reading = await response.text();
      // Display reading
    }
  } catch (error) {
    console.error("Error:", error);
  }
};```