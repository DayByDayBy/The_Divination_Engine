/**
 * P0-002: JWT Interoperability Test
 * 
 * Validates that JWTs generated by Java backend can be decoded in Node.js (jose library),
 * and that TypeScript-generated JWTs follow the same format.
 * 
 * ABORT CONDITION: If JWT libraries produce fundamentally incompatible tokens, abort migration.
 */

import { SignJWT, jwtVerify, decodeJwt } from 'jose';

// Test configuration - matches Java JwtUtil
const TEST_SECRET = 'this-is-a-test-secret-key-that-is-at-least-32-bytes-long';
const TEST_USER_ID = '550e8400-e29b-41d4-a716-446655440000';
const TEST_TIER = 'FREE';

/**
 * Creates a secret key from string (matching Java's Keys.hmacShaKeyFor)
 */
function getSecretKey(secret: string): Uint8Array {
  return new TextEncoder().encode(secret);
}

/**
 * Generates a JWT matching Java format exactly
 */
async function generateToken(userId: string, tier: string, secret: string): Promise<string> {
  const secretKey = getSecretKey(secret);
  
  const jwt = await new SignJWT({ tier })
    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })
    .setSubject(userId)
    .setIssuedAt()
    .setExpirationTime('24h')
    .sign(secretKey);
  
  return jwt;
}

/**
 * Validates and extracts claims from a JWT
 */
async function validateToken(token: string, secret: string): Promise<{
  userId: string;
  tier: string;
  issuedAt: Date;
  expiresAt: Date;
}> {
  const secretKey = getSecretKey(secret);
  
  const { payload } = await jwtVerify(token, secretKey);
  
  return {
    userId: payload.sub as string,
    tier: payload.tier as string,
    issuedAt: new Date((payload.iat as number) * 1000),
    expiresAt: new Date((payload.exp as number) * 1000),
  };
}

/**
 * Decodes a JWT without verification (for inspection)
 */
function decodeTokenWithoutVerification(token: string): {
  header: Record<string, unknown>;
  payload: Record<string, unknown>;
} {
  const payload = decodeJwt(token);
  const headerBase64 = token.split('.')[0];
  const header = JSON.parse(Buffer.from(headerBase64, 'base64url').toString());
  
  return { header, payload };
}

// ============================================================================
// Test Cases
// ============================================================================

describe('JWT Interoperability Tests', () => {
  
  describe('TypeScript JWT Generation', () => {
    
    test('should generate valid JWT with correct claims', async () => {
      const token = await generateToken(TEST_USER_ID, TEST_TIER, TEST_SECRET);
      
      expect(token).toBeDefined();
      expect(token.split('.').length).toBe(3); // header.payload.signature
      
      const decoded = decodeTokenWithoutVerification(token);
      
      // Verify header
      expect(decoded.header.alg).toBe('HS256');
      expect(decoded.header.typ).toBe('JWT');
      
      // Verify payload claims
      expect(decoded.payload.sub).toBe(TEST_USER_ID);
      expect(decoded.payload.tier).toBe(TEST_TIER);
      expect(decoded.payload.iat).toBeDefined();
      expect(decoded.payload.exp).toBeDefined();
      
      // Verify expiration is ~24h from now
      const exp = decoded.payload.exp as number;
      const iat = decoded.payload.iat as number;
      const diffHours = (exp - iat) / 3600;
      expect(diffHours).toBeCloseTo(24, 0);
    });
    
    test('should validate generated token successfully', async () => {
      const token = await generateToken(TEST_USER_ID, TEST_TIER, TEST_SECRET);
      const claims = await validateToken(token, TEST_SECRET);
      
      expect(claims.userId).toBe(TEST_USER_ID);
      expect(claims.tier).toBe(TEST_TIER);
      expect(claims.issuedAt).toBeInstanceOf(Date);
      expect(claims.expiresAt).toBeInstanceOf(Date);
      expect(claims.expiresAt.getTime()).toBeGreaterThan(claims.issuedAt.getTime());
    });
    
    test('should reject token with wrong secret', async () => {
      const token = await generateToken(TEST_USER_ID, TEST_TIER, TEST_SECRET);
      const wrongSecret = 'wrong-secret-that-is-also-at-least-32-bytes';
      
      await expect(validateToken(token, wrongSecret)).rejects.toThrow();
    });
    
  });
  
  describe('Java JWT Compatibility', () => {
    
    // Example JWT that would be generated by Java backend
    // This simulates what Java's JwtUtil.generateToken() produces
    test('should decode Java-format JWT correctly', async () => {
      // Generate a token in the same format Java uses
      const javaStyleToken = await generateToken(TEST_USER_ID, TEST_TIER, TEST_SECRET);
      
      const decoded = decodeTokenWithoutVerification(javaStyleToken);
      
      // Java uses these exact claim names
      expect(decoded.payload).toHaveProperty('sub'); // subject (userId)
      expect(decoded.payload).toHaveProperty('tier'); // custom claim
      expect(decoded.payload).toHaveProperty('iat'); // issuedAt
      expect(decoded.payload).toHaveProperty('exp'); // expiration
    });
    
    test('should handle all tier values', async () => {
      const tiers = ['FREE', 'BASIC', 'PREMIUM'];
      
      for (const tier of tiers) {
        const token = await generateToken(TEST_USER_ID, tier, TEST_SECRET);
        const claims = await validateToken(token, TEST_SECRET);
        expect(claims.tier).toBe(tier);
      }
    });
    
    test('should handle UUID format for userId', async () => {
      const uuids = [
        '550e8400-e29b-41d4-a716-446655440000',
        '00000000-0000-0000-0000-000000000000',
        'ffffffff-ffff-ffff-ffff-ffffffffffff',
      ];
      
      for (const uuid of uuids) {
        const token = await generateToken(uuid, TEST_TIER, TEST_SECRET);
        const claims = await validateToken(token, TEST_SECRET);
        expect(claims.userId).toBe(uuid);
      }
    });
    
  });
  
  describe('Edge Cases', () => {
    
    test('should reject expired token', async () => {
      const secretKey = getSecretKey(TEST_SECRET);
      
      // Create an already-expired token
      const expiredToken = await new SignJWT({ tier: TEST_TIER })
        .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })
        .setSubject(TEST_USER_ID)
        .setIssuedAt(new Date(Date.now() - 48 * 60 * 60 * 1000)) // 48h ago
        .setExpirationTime(new Date(Date.now() - 24 * 60 * 60 * 1000)) // 24h ago
        .sign(secretKey);
      
      await expect(validateToken(expiredToken, TEST_SECRET)).rejects.toThrow();
    });
    
    test('should reject malformed token', async () => {
      const malformedTokens = [
        '',
        'not-a-jwt',
        'header.payload', // missing signature
        'header.payload.signature.extra', // too many parts
        'aaa.bbb.ccc', // invalid base64
      ];
      
      for (const token of malformedTokens) {
        await expect(validateToken(token, TEST_SECRET)).rejects.toThrow();
      }
    });
    
    test('should handle token with missing optional claims gracefully', async () => {
      const secretKey = getSecretKey(TEST_SECRET);
      
      // Token without tier claim - tier is optional, validation should still succeed
      const tokenNoTier = await new SignJWT({})
        .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })
        .setSubject(TEST_USER_ID)
        .setIssuedAt()
        .setExpirationTime('24h')
        .sign(secretKey);
      
      const claims = await validateToken(tokenNoTier, TEST_SECRET);
      expect(claims.tier).toBeUndefined();
    });
    
  });
  
  describe('Secret Key Requirements', () => {
    
    test('should work with 32+ byte secret (256 bits)', async () => {
      const validSecret = 'a'.repeat(32); // Exactly 32 bytes
      const token = await generateToken(TEST_USER_ID, TEST_TIER, validSecret);
      const claims = await validateToken(token, validSecret);
      expect(claims.userId).toBe(TEST_USER_ID);
    });
    
    test('should work with longer secrets', async () => {
      const longSecret = 'a'.repeat(64); // 64 bytes
      const token = await generateToken(TEST_USER_ID, TEST_TIER, longSecret);
      const claims = await validateToken(token, longSecret);
      expect(claims.userId).toBe(TEST_USER_ID);
    });
    
  });
  
});

// ============================================================================
// Standalone Validation Script
// ============================================================================

/**
 * Run this to validate interoperability manually:
 * npx ts-node test/jwt-interoperability.test.ts
 */
async function runManualValidation() {
  console.log('=== JWT Interoperability Validation ===\n');
  
  try {
    // 1. Generate TypeScript JWT
    console.log('1. Generating TypeScript JWT...');
    const token = await generateToken(TEST_USER_ID, TEST_TIER, TEST_SECRET);
    console.log(`   Token: ${token.substring(0, 50)}...`);
    
    // 2. Decode without verification
    console.log('\n2. Decoding token (without verification)...');
    const decoded = decodeTokenWithoutVerification(token);
    console.log('   Header:', JSON.stringify(decoded.header));
    console.log('   Payload:', JSON.stringify(decoded.payload));
    
    // 3. Validate with verification
    console.log('\n3. Validating token (with signature verification)...');
    const claims = await validateToken(token, TEST_SECRET);
    console.log('   User ID:', claims.userId);
    console.log('   Tier:', claims.tier);
    console.log('   Issued At:', claims.issuedAt.toISOString());
    console.log('   Expires At:', claims.expiresAt.toISOString());
    
    // 4. Test wrong secret rejection
    console.log('\n4. Testing wrong secret rejection...');
    try {
      await validateToken(token, 'wrong-secret-that-is-32-bytes-long');
      console.log('   ERROR: Should have rejected!');
    } catch {
      console.log('   ✓ Correctly rejected token with wrong secret');
    }
    
    console.log('\n=== All Validations Passed ===');
    console.log('\nJWT FORMAT CONFIRMED:');
    console.log('- Algorithm: HS256');
    console.log('- Claims: sub (UUID), tier (string), iat (number), exp (number)');
    console.log('- Secret: HMAC-SHA256 with UTF-8 encoded string (min 32 bytes)');
    console.log('\n✓ TypeScript (jose) is COMPATIBLE with Java (jjwt)');
    
  } catch (error) {
    console.error('\n!!! VALIDATION FAILED !!!');
    console.error(error);
    console.log('\n⚠️ ABORT CONDITION: JWT libraries may be incompatible');
    process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  runManualValidation();
}
